### setup.py
import setuptools

with open("README.md", "r") as fh:
    long_description = fh.read()

setuptools.setup(
    name="streamlit_notebook",
    version="0.0.5",
    author="Baptiste Ferrand",
    author_email="bferrand.maths@gmail.com",
    description="A notebook interface for Streamlit.",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/B4PT0R/streamlit_notebook",
    packages=setuptools.find_packages(),
        package_data={
        'streamlit_notebook': [
            'app_images/*',
        ]
    },
    entry_points={
        'console_scripts': [
            'st_notebook=streamlit_notebook.launch_app:main',
        ],
    },
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    install_requires=[
        "streamlit-code-editor==0.1.20",
        "streamlit>=1.35.0",
        "matplotlib",
        "numpy",
        "seaborn",
        "pandas",
        "graphviz",
        "altair",
        "plotly",
        "bokeh",
        "pydeck",
        "scipy",
        "sympy",
        "scikit-learn",
        "vega-datasets"
    ],
    python_requires='>=3.9',
)


### compil.py
import os
import pathlib

def compile_python_files(output_filename="all.txt"):
    # Utiliser le module pathlib pour naviguer dans les fichiers et dossiers
    base_path = pathlib.Path('.')
    with open(output_filename, "w", encoding="utf-8") as outfile:
        # Parcourir tous les fichiers .py dans le répertoire courant et les sous-dossiers
        for filepath in base_path.rglob('*.py'):
            # Ignorer les fichiers dans les répertoires 'build', 'dist', et '__pycache__'
            if 'build' in filepath.parts or 'dist' in filepath.parts or '__pycache__' in filepath.parts:
                continue
            with open(filepath, "r", encoding="utf-8") as infile:
                # Écrire le nom du fichier avec un chemin relatif par rapport à base_path
                outfile.write(f"### {filepath.relative_to(base_path)}\n")
                outfile.write(infile.read())
                outfile.write("\n\n")


if __name__ == "__main__":
    compile_python_files()

### streamlit_notebook/main.py
import streamlit as st
from .notebook import st_notebook

st.set_page_config(initial_sidebar_state="collapsed")

st_notebook()


### streamlit_notebook/launch_app.py
import subprocess
import os

def main():
    # Get the directory of the current script
    script_directory = os.path.dirname(os.path.abspath(__file__))

    # Command to run the Streamlit app
    command = f"streamlit run {os.path.join(script_directory, 'main.py')}"

    # Execute the command
    subprocess.run(command, shell=True)

if __name__ == '__main__':
    main()

### streamlit_notebook/__init__.py
from .notebook import st_notebook

### streamlit_notebook/editor.py
from code_editor import code_editor

class editor_output_parser:
    def __init__(self):
        self.last_id=None

    def __call__(self,output):
        content=output["text"]
        if 'id' in output and not output['id']==self.last_id:
            self.last_id=output['id']
            if not output["type"]=='':
                event=output["type"]
            else:
                event=None
        else:
            event=None
        return event,content


def editor(*args,**kwargs):

    buttons=[
        {
            "name": "Run",
            "feather": "Play",
            "primary": True,
            "hasText": False,
            "alwaysOn":True,
            "showWithIcon": True,
            "commands": [
                ["response","run"]
            ],
            "style": {
            "bottom": "0.44rem",
            "right": "0.4rem"
            }
        }
    ]


    params=dict(
        theme='default',
        buttons=buttons,
        options={
            "showLineNumbers":True
        },
        props={ 
            "enableBasicAutocompletion": False, 
            "enableLiveAutocompletion": False, 
            "enableSnippets": False
        }
    )

    params.update(**kwargs)

    output=code_editor(*args,**params)
    return output
    




### streamlit_notebook/notebook.py
from .state import state, init_state
from .cell import CodeCell,MarkdownCell
import streamlit as st 
import os

os.environ['APP_ROOT_PATH']=os.path.dirname(os.path.abspath(__file__))

def root_join(*args):
    return os.path.join(os.getenv('APP_ROOT_PATH'),*args)

class Notebook:

    """
    A Streamlit notebook object.
    """

    def __init__(self):
        init_state(
            cells={},
            current_cell_key=0,
            hide_code_cells=False,
            run_on_submit=True,
            show_logo=True,
            rerun=False
        )
        st.notebook=self

    def __getattr__(self,name):
        if name in state:
            return state[name]
        else:
            return super().__getattribute__(name)

    def show(self):

        """
        Renders the notebook's UI 
        """

        self.logo()        

        self.sidebar()

        for cell in list(state.cells.values()):
            cell.show()

        self.control_bar()

        if state.rerun:
            state.rerun=False
            st.rerun()
    
    def sidebar(self):
        with st.sidebar:
            st.image(root_join("app_images","st_notebook.png"),use_column_width=True)
            st.divider()
            def on_change():
                state.hide_code_cells=not state.hide_code_cells
            st.toggle("App mode",value=state.hide_code_cells,on_change=on_change, key="toggle_hide_cells")
            def on_change():
                state.run_on_submit=not state.run_on_submit
            st.toggle("Run cell on submit",value=state.run_on_submit,on_change=on_change,key="toggle_run_on_submit")
            def on_change():
                state.show_logo=not state.show_logo
            st.toggle("Show logo",value=state.show_logo,on_change=on_change,key="toggle_show_logo")
            st.divider()
            def on_click():
                self.clear_cells()
            st.button("Clear all cells",on_click=on_click,use_container_width=True,key="button_clear_cells")
            def on_click():
                self.run_all_cells()
            st.button("Run all cells",on_click=on_click,use_container_width=True,key="button_run_all_cells")



    def logo(self):
        if state.show_logo:
            _,c,_=st.columns([40,40,40])
            c.image(root_join("app_images","st_notebook.png"),use_column_width=True)


    def control_bar(self):
        if not state.hide_code_cells:
            c1,c2=st.columns(2)

            code_button=c1.button("New code cell",use_container_width=True,key="new_code_cell_button")
            mkdwn_button=c2.button("New Markdown cell",use_container_width=True,key="new_mkdwn_cell_button")
            
            if code_button:
                self.add_code_cell()
            if mkdwn_button:
                self.add_mkdwn_cell()

    def clear_cells(self):
        state.cells={}
        state.current_cell_key=0
        state.rerun=True

    def run_all_cells(self):
        for cell in state.cells.values():
            cell.has_run=False
            cell.run()


    def add_code_cell(self,code=""):
        """
        Adds a new code cell at the bottom of the notebook.
        """
        state.cells[state.current_cell_key]=CodeCell(code,state.current_cell_key)
        state.current_cell_key+=1
        state.rerun=True

    def add_mkdwn_cell(self,code=""):
        """
        Adds a new  Markdown cell at the bottom of the notebook.
        """
        state.cells[state.current_cell_key]=MarkdownCell(code,state.current_cell_key)
        state.current_cell_key+=1
        state.rerun=True


def st_notebook():
    if not 'notebook' in state:
        state.notebook=Notebook()
    state.notebook.show()


### streamlit_notebook/state.py
import streamlit as st

state=st.session_state

def init_state(**kwargs):
    for name,value in kwargs.items():
        if not name in state:
            state[name]=value



### streamlit_notebook/utils.py
import re

def format(string, **kwargs):
    # Si aucun contexte n'est fourni, utiliser un dictionnaire vide
    if not kwargs:
        context = {}
    else:
        context=kwargs
    # Trouver les expressions entre <<...>>
    def replace_expr(match):
        expr = match.group(1)
        try:
            # Évaluer l'expression dans le contexte donné et la convertir en chaîne
            return str(eval(expr, context))
        except Exception as e:
            # print(f"could not evaluate expr: {expr}\n Exception:\n {str(e)}")
            # En cas d'erreur, retourner l'expression non évaluée
            return '<<' + expr + '>>'
    # Remplacer chaque expression par son évaluation
    return re.sub(r'<<(.*?)>>', replace_expr, string)

### streamlit_notebook/cell.py
import streamlit as st
from .state import state
from .editor import editor, editor_output_parser
from .utils import format

class Cell:

    "Implements the main notebook cell from which other cell types inherit"

    def __init__(self,code,key,auto_rerun=True):
        self.code=code
        self.submitted_code=""
        self.key=key
        self.visible=True
        self.auto_rerun=auto_rerun
        self.output=None
        self.output_area=None
        self.has_run=False
        self.parser=editor_output_parser()
        self.language="python"
        self.type="code"

    def show(self):
        self.has_run=False
        self.container=st.container()
        self.output_area=st.empty()
        self.output=self.output_area.container()
        if self.auto_rerun:
            self.run()
        if not state.hide_code_cells and self.visible:
            with self.container.container(border=True):
                self.menu_bar()
                event,new_code=self.parser(editor(self.code,lang=self.language,key=f"cell_editor_{self.key}"))
                if event=="submit":
                    self.has_run=False
                    self.code=new_code
                    self.submitted_code=self.code
                    if state.run_on_submit:
                        self.run()
                if event=="run":
                    self.has_run=False
                    self.code=new_code
                    self.submitted_code=self.code
                    self.run()
                self.status_bar()

    @property
    def rank(self):
        return list(state.cells.keys()).index(self.key)


    def rerank(self,rank):
        if 0<=rank<len(state.cells) and not rank==self.rank:
            keys=list(state.cells.keys())
            del keys[self.rank]
            keys.insert(rank,self.key)
            state.cells={k:state.cells[k] for k in keys}

    def move_up(self):
        self.rerank(self.rank-1)

    def move_down(self):
        self.rerank(self.rank+1)


    def menu_bar(self):
        c1,c2,c3,_,c4,c5,c6=st.columns([7,30,30,20,5,5,5])
        c1.text(f"[{self.key}]")
        c2.toggle("Auto-Rerun",value=self.auto_rerun,on_change=self.switch_auto_rerun,key=f"cell_auto_rerun_{self.key}")
        #c3.toggle("Run as fragment",value=self.fragment,on_change=self.switch_fragment,key=f"cell_fragment_{self.key}")
        c4.button("🔺",on_click=self.move_up,key=f"cell_move_up_{self.key}",use_container_width=True)
        c5.button("🔻",on_click=self.move_down,key=f"cell_move_down_{self.key}",use_container_width=True)
        c6.button("❌",on_click=self.delete,key=f"cell_close_{self.key}",use_container_width=True)

    def status_bar(self):
        c1,_,c2=st.columns([15,85,5])
        c1.caption(self.type)
        if self.has_run:
            c2.write("✅")

    def switch_auto_run(self):
        self.auto_run=not self.auto_run

    def switch_auto_rerun(self):
        self.auto_rerun=not self.auto_rerun

    def delete(self):
        if self.key in state.cells:
            del state.cells[self.key]

    def run(self):
        raise NotImplementedError("Subclasses of Cell should implement a run method.")
            
class CodeCell(Cell):

    """
    The Streamlit notebook code cell object
    """

    def __init__(self,code,key,fragment=False,auto_rerun=True):
        super().__init__(code,key,auto_rerun=auto_rerun)
        self.fragment=fragment

    def menu_bar(self):
        """
        Renders the menu bar of the code cell.
        """
        c1,c2,c3,_,c4,c5,c6=st.columns([7,30,30,20,5,5,5])
        c1.text(f"[{self.key}]")
        c2.toggle("Auto-Rerun",value=self.auto_rerun,on_change=self.switch_auto_rerun,key=f"cell_auto_rerun_{self.key}")
        c3.toggle("Run as fragment",value=self.fragment,on_change=self.switch_fragment,key=f"cell_fragment_{self.key}")
        c4.button("🔺",on_click=self.move_up,key=f"cell_move_up_{self.key}",use_container_width=True)
        c5.button("🔻",on_click=self.move_down,key=f"cell_move_down_{self.key}",use_container_width=True)
        c6.button("❌",on_click=self.delete,key=f"cell_close_{self.key}",use_container_width=True)

    def run(self):
        """
        Runs the code written in the cell.
        """
        if not self.has_run and self.submitted_code:
            self.output=self.output_area.container()
            with self.output:
                if self.fragment:
                    self.exec_as_fragment()
                else:
                    self.exec()
            self.has_run=True
    
    def switch_fragment(self):
        self.fragment=not self.fragment

    @st.experimental_fragment
    def exec_as_fragment(self):
        try:
            exec(self.submitted_code,globals())
        except Exception as e:
            st.exception(e)

    def exec(self):
        try:
            exec(self.submitted_code,globals())
        except Exception as e:
            st.exception(e)

class MarkdownCell(Cell):

    def __init__(self,code,key,auto_rerun=True):
        super().__init__(code,key,auto_rerun=auto_rerun)
        self.language="markdown"
        self.type="markdown"

    def run(self):
        if not self.has_run and self.submitted_code:
            self.output=self.output_area.container()
            with self.output:
                self.exec()
            self.has_run=True

    def exec(self):
        try:
            formatted_code=format(self.submitted_code,**state,**globals())
            code=f'st.markdown(r"""{formatted_code}""")'
            exec(code,globals())
        except Exception as e:
            st.exception(e)


