# Generated by Streamlit Notebook
# Original notebook: machine_learning_demo
# This file can be run directly with: streamlit run <filename>

from streamlit_notebook import get_notebook, render_notebook
import streamlit as st

st.set_page_config(page_title="st.notebook", layout="centered", initial_sidebar_state="collapsed")

nb = get_notebook(title='machine_learning_demo')

@nb.cell(type='markdown', auto_rerun=True, fragment=False)
def cell_0():
    r'''
    # Interactive Machine Learning
    This notebook demonstrates how to create an interactive machine learning demo using scikit-learn and Streamlit widgets. We'll create a simple classifier and visualize its decision boundaries.
    '''

@nb.cell(type='code', auto_rerun=False, fragment=False)
def cell_1():
    from sklearn.datasets import make_classification
    from sklearn.model_selection import train_test_split
    from sklearn.svm import SVC
    from sklearn.metrics import accuracy_score
    import numpy as np
    import matplotlib.pyplot as plt

    # Generate dataset
    X, y = make_classification(n_samples=100, n_features=2, n_redundant=0, n_classes=2,
                               n_clusters_per_class=1, random_state=42)

    # Split data
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

@nb.cell(type='code', auto_rerun=True, fragment=False)
def cell_2():
    # Interactive parameters
    kernel = st.selectbox('Kernel', ['linear', 'rbf', 'poly'])
    C = st.slider('C (Regularization)', 0.1, 10.0, 1.0)

    # Train model
    model = SVC(kernel=kernel, C=C)
    model.fit(X_train, y_train)

    # Make predictions
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)

    st.write(f'Test Accuracy: {accuracy:.2f}')

@nb.cell(type='code', auto_rerun=True, fragment=False)
def cell_3():
    # Plot decision boundary
    def plot_decision_boundary(model, X, y):
        h = 0.02  # step size in the mesh
        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
        xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))
        Z = model.predict(np.c_[xx.ravel(), yy.ravel()])
        Z = Z.reshape(xx.shape)

        plt.figure(figsize=(10, 8))
        plt.contourf(xx, yy, Z, alpha=0.4)
        plt.scatter(X[:, 0], X[:, 1], c=y, alpha=0.8)
        plt.title(f'SVM Decision Boundary (Kernel: {kernel}, C: {C})')
        return plt.gcf()

    fig = plot_decision_boundary(model, X, y)
    st.pyplot(fig);

# Render the notebook
# Using render_notebook() instead of nb.render() allows the notebook
# to be replaced dynamically (e.g., when loading a different file)
render_notebook()