# Generated by Streamlit Notebook
# Original notebook: interactive_julia_set_demo
# This file can be run directly with: streamlit run <filename>

from streamlit_notebook import get_notebook, render_notebook
import streamlit as st

st.set_page_config(page_title="st.notebook", layout="centered", initial_sidebar_state="collapsed")

nb = get_notebook(title='interactive_julia_set_demo', app_mode=True)

@nb.cell(type='markdown', auto_rerun=True, fragment=False)
def cell_0():
    r'''
    # Interactive Julia Set Visualization

    This notebook demonstrates an efficient way to visualize Julia sets with interactive parameter control. 

    The Julia set for a complex parameter $c$ is the set of complex numbers $z$ for which the function $f_c(z) = z^2 + c$ does not escape to infinity when applied iteratively.

    We'll first precompute several Julia sets for different values of $c$, store them in memory, and then provide a smooth interface to view them interactively.
    '''

@nb.cell(type='code', auto_rerun=False, fragment=False)
def cell_1():
    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib.colors import LinearSegmentedColormap

    def compute_julia(h, w, c, max_iter):
        y, x = np.ogrid[-1.4:1.4:h*1j, -1.4:1.4:w*1j]
        z = x + y*1j
        divtime = max_iter + np.zeros(z.shape, dtype=int)

        for i in range(max_iter):
            z = z**2 + c
            diverge = z*np.conj(z) > 2**2
            div_now = diverge & (divtime == max_iter)
            divtime[div_now] = i
            z[diverge] = 2

        return divtime

    # Create a custom colormap
    colors = [(0, 0, 0), (0.5, 0, 0), (1, 0, 0), (1, 0.5, 0),
             (1, 1, 0), (0, 1, 0), (0, 1, 1), (0, 0, 1)]
    julia_map = LinearSegmentedColormap.from_list('julia', colors)

    # Precompute Julia sets for various values of c
    h, w = 500, 500
    max_iter = 100

    # Generate points on a circle for c values
    thetas = np.linspace(0, 2*np.pi, 51)[:-1]  # 50 points
    radius = 0.4
    c_values = radius * np.exp(1j * thetas)

    # Compute and store Julia sets
    julia_sets = {}
    for i, c in enumerate(c_values):
        print(f'Computing Julia set {i+1}/50...')
        julia_sets[c] = compute_julia(h, w, c, max_iter)

    print('Computation complete!')

@nb.cell(type='markdown', auto_rerun=True, fragment=False)
def cell_2():
    r'''
    ## Interactive Visualization

    Use the slider below to change the value of $c$.
    '''

@nb.cell(type='code', auto_rerun=True, fragment=False)
def cell_3():
    # Interactive control
    theta = st.slider('θ (angle of c)', 0.0, 2*np.pi, 0.0, 0.1,key="theta")
    c = radius * np.exp(1j * theta)

    # Find closest precomputed c value
    c_diffs = np.abs(c - c_values)
    nearest_c = c_values[np.argmin(c_diffs)]

    # Plot the Julia set
    plt.figure(figsize=(10, 10))
    plt.imshow(julia_sets[nearest_c], cmap=julia_map)
    plt.axis('off')
    plt.title(f'Julia Set for c ≈ {nearest_c:.3f}')
    st.pyplot(plt.gcf());

@nb.cell(type='markdown', auto_rerun=True, fragment=False)
def cell_4():
    r'''
    ### Implementation Notes

    1. We precompute 50 different Julia sets for c values around a circle of radius 0.4 in the complex plane.
    2. When you move the slider, we find the nearest precomputed set rather than computing a new one.
    3. This approach gives us smooth interactivity while maintaining visual quality.
    4. The custom colormap creates beautiful visualizations of the escape-time values.
    '''

# Render the notebook
# Using render_notebook() instead of nb.render() allows the notebook
# to be replaced dynamically (e.g., when loading a different file)
render_notebook()